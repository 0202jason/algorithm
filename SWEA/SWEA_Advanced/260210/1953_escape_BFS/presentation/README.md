## 🎙️ [강의] 탈주범 검거: BFS와 Queue의 메커니즘

### 1. BFS를 왜 쓸까? (핵심 로직)

DFS가 한 놈만 패면서 끝까지 가보는 거라면, BFS는 **내 주변부터 공평하게 한 칸씩** 넓혀가는 거야. 탈주범이 1시간에 1칸씩 가니까, "L시간 동안 퍼져나갈 수 있는 모든 구역"을 찾기에 딱이지. 여기서 **Queue(큐)**는 **"다음에 가볼 곳들을 순서대로 적어둔 대기표"**라고 생각하면 돼.

### 2. Queue의 동작과 변수 변화 (상세 분석)

네 코드의 `queue = deque([(i, j, 1)])` 부분을 집중적으로 보자.

#### ① 큐에 데이터 넣기 (Push/Append)

* **상황:** 현재 위치 `(i, j)`에서 연결된 다음 칸 `(ni, nj)`를 발견했어!
* **동작:** "야, 너도 나중에 가봐야 하니까 줄 서!" 하고 큐 뒤에 붙여.
* **데이터:** `(ni, nj, curr_time + 1)`. 여기서 `time`을 1 늘려서 저장하는 게 핵심이야. 그래야 내가 몇 시간째에 거기 도착했는지 알 수 있거든.

#### ② 큐에서 데이터 빼기 (Popleft)

* **상황:** 현재 칸에서 할 일을 다 했어. 이제 다음 대기자를 불러야지?
* **동작:** `queue.popleft()`. 줄 맨 앞에 서 있던 놈을 꺼내서 **현재 조사 대상**으로 삼아.

---

## 📊 변수 추적 시뮬레이션 (Trace Table)

`L = 3` (3시간)이고 시작점이 `(0,0)`이라 가정해보자.

| 스텝 | Queue 상태 (맨 앞이 다음 대상) | 현재 조사 중 (`popleft`) | `count` | 비고 |
| --- | --- | --- | --- | --- |
| **1** | `[(0,0,1)]` | - | 1 | 시작점 큐에 넣고 count 시작 |
| **2** | `[]` | `(0,0,1)` | 1 | `(0,0)` 주변 조사 시작. 상하좌우 체크! |
| **3** | `[(0,1,2), (1,0,2)]` | - | 3 | 연결된 두 곳을 큐에 추가. `time`은 2가 됨. |
| **4** | `[(1,0,2)]` | `(0,1,2)` | 3 | `(0,1)` 주변 조사. 새로 갈 곳 없으면 끝. |
| **5** | `[(1,1,3)]` | `(1,0,2)` | 4 | `(1,0)` 주변 조사 중 `(1,1)` 발견! 큐에 추가. |

> **중요!** 만약 `popleft` 했을 때 `curr_time >= L`이면, 그 놈은 큐에서 빠지기만 하고 주변 조사를 안 해. 시간이 다 됐으니까! 이게 네 코드의 `if curr_time >= L: continue` 로직이야.

---

## 🧐 기술적 분석 (Best Practice)

| 특징 | 장점 | 단점 |
| --- | --- | --- |
| **`deque` 사용** | 일반 `list.pop(0)`은 $O(N)$이지만, `deque.popleft()`는 $O(1)$이라 성능이 압도적임. | `collections` 모듈을 임포트해야 함. |
| **방향 역전 (`oppo`)** | `if`문을 도배하는 대신 딕셔너리로 간단히 해결. (매우 전문적임) | 딕셔너리 정의할 때 오타 나면 찾기 힘듦. |

---
