## 🎙️ [강의] 탈주범 검거: BFS와 Queue의 메커니즘

### 1. BFS를 왜 쓸까? (핵심 로직)

DFS가 한 놈만 패면서 끝까지 가보는 거라면, BFS는 **내 주변부터 공평하게 한 칸씩** 넓혀가는 거야. 탈주범이 1시간에 1칸씩 가니까, "L시간 동안 퍼져나갈 수 있는 모든 구역"을 찾기에 딱이지. 여기서 **Queue(큐)**는 **"다음에 가볼 곳들을 순서대로 적어둔 대기표"**라고 생각하면 돼.

### 2. Queue의 동작과 변수 변화 (상세 분석)

네 코드의 `queue = deque([(i, j, 1)])` 부분을 집중적으로 보자.

#### ① 큐에 데이터 넣기 (Push/Append)

* **상황:** 현재 위치 `(i, j)`에서 연결된 다음 칸 `(ni, nj)`를 발견했어!
* **동작:** "야, 너도 나중에 가봐야 하니까 줄 서!" 하고 큐 뒤에 붙여.
* **데이터:** `(ni, nj, curr_time + 1)`. 여기서 `time`을 1 늘려서 저장하는 게 핵심이야. 그래야 내가 몇 시간째에 거기 도착했는지 알 수 있거든.

#### ② 큐에서 데이터 빼기 (Popleft)

* **상황:** 현재 칸에서 할 일을 다 했어. 이제 다음 대기자를 불러야지?
* **동작:** `queue.popleft()`. 줄 맨 앞에 서 있던 놈을 꺼내서 **현재 조사 대상**으로 삼아.

---

## 📊 변수 추적 시뮬레이션 (Trace Table)

`L = 3` (3시간)이고 시작점이 `(0,0)`이라 가정해보자.

| 스텝 | Queue 상태 (맨 앞이 다음 대상) | 현재 조사 중 (`popleft`) | `count` | 비고 |
| --- | --- | --- | --- | --- |
| **1** | `[(0,0,1)]` | - | 1 | 시작점 큐에 넣고 count 시작 |
| **2** | `[]` | `(0,0,1)` | 1 | `(0,0)` 주변 조사 시작. 상하좌우 체크! |
| **3** | `[(0,1,2), (1,0,2)]` | - | 3 | 연결된 두 곳을 큐에 추가. `time`은 2가 됨. |
| **4** | `[(1,0,2)]` | `(0,1,2)` | 3 | `(0,1)` 주변 조사. 새로 갈 곳 없으면 끝. |
| **5** | `[(1,1,3)]` | `(1,0,2)` | 4 | `(1,0)` 주변 조사 중 `(1,1)` 발견! 큐에 추가. |

> **중요!** 만약 `popleft` 했을 때 `curr_time >= L`이면, 그 놈은 큐에서 빠지기만 하고 주변 조사를 안 해. 시간이 다 됐으니까! 이게 네 코드의 `if curr_time >= L: continue` 로직이야.

---

## 🧐 기술적 분석 (Best Practice)

| 특징 | 장점 | 단점 |
| --- | --- | --- |
| **`deque` 사용** | 일반 `list.pop(0)`은 $O(N)$이지만, `deque.popleft()`는 $O(1)$이라 성능이 압도적임. | `collections` 모듈을 임포트해야 함. |
| **방향 역전 (`oppo`)** | `if`문을 도배하는 대신 딕셔너리로 간단히 해결. (매우 전문적임) | 딕셔너리 정의할 때 오타 나면 찾기 힘듦. |

---

야, 너 아주 중요한 포인트를 짚었다! 재귀(Recursion) 공부하다 보면 가장 머리 아픈 게 바로 이 **'Backtracking(백트래킹)'** 시점이야. `v.pop()`이 도대체 언제 실행되는 건지, 왜 저 위치에 있어야 하는지 뇌에 박히게 설명해줄게.

---


## 🧠 백트래킹의 핵심: "내 일 끝났으니 원상복구해라"

결론부터 말하면, `v.pop()`은 **`dfs` 함수가 하나 종료(return)될 때마다 바로 직전 함수에서 실행**되는 거야.

### 1. 왜 `dfs()` 호출 바로 밑에 있을까?

재귀 호출은 함수가 끝날 때까지 다음 줄로 넘어가지 않아.

1. `v.append()`: "야, 나 이 카페 디저트 먹었어!" (장바구니에 넣기)
2. `dfs()`: "자, 그럼 다음 칸으로 가서 또 먹어봐." (다음 집 방문)
3. **... (한참 뒤에 다음 집 방문이 다 끝나고 돌아오면) ...**
4. `v.pop()`: "휴, 다음 집 투어 끝났네? 그럼 방금 먹었던 건 다시 빼줄게. 그래야 다른 길로 갈 때 배가 안 부르지!" (원상복구)

---


## 📊 시뮬레이션: 스택에서 벌어지는 일

간단하게 디저트 번호 `[9, 8, 7]` 순서로 이동한다고 생각해보자.

| 단계 | 현재 상태 | 행동 | 장바구니 `v` | 비고 |
| --- | --- | --- | --- | --- |
| **1** | `dfs(9)` 실행 | `v.append(8)` 후 `dfs(8)` 호출 | `[9, 8]` | 8번 방문 중 |
| **2** | `dfs(8)` 실행 | `v.append(7)` 후 `dfs(7)` 호출 | `[9, 8, 7]` | 7번 방문 중 |
| **3** | `dfs(7)` 끝 | 더 이상 갈 곳 없어 `return` | `[9, 8, 7]` | 함수 종료 |
| **4** | **`dfs(8)`로 복귀** | **`v.pop()` 실행!** | `[9, 8]` | **7번을 뱉어냄** |
| **5** | `dfs(8)` 끝 | `return` | `[9, 8]` | 함수 종료 |
| **6** | **`dfs(9)`로 복귀** | **`v.pop()` 실행!** | `[9]` | **8번을 뱉어냄** |

---

## 🧐 기술적 분석: 이 방식의 장점과 주의점

이걸 전문 용어로 **"State Restoration(상태 복구)"**라고 불러.

* **장점:** `v`라는 리스트 하나만 계속 돌려쓰니까 메모리를 엄청나게 아낄 수 있어. (새로 복사본을 안 만드니까)
* **주의점 (실수 포인트):** 만약 `v.pop()`을 안 하면? 한 번 경로 탐색할 때 먹은 디저트가 다음 경로 탐색할 때도 그대로 남아있어서, "어? 이거 아까 먹은 거네?" 하고 탐색을 안 해버리는 대참사가 발생해.

---

## 💡 Best Practice: 복사 vs 원본 수정

가끔 초보들은 `dfs(ni, nj, k, v + [matrix[ni][nj]])` 이런 식으로 짜기도 해.

* **복사 방식:** `v + [...]`를 하면 알아서 새로운 리스트가 만들어져서 넘어가니까 `pop()`이 필요 없어.
* **원본 수정 방식 (네 방식):** 하지만 리스트를 매번 복사하면 시간이 엄청 걸려서 **코테에서는 무조건 네 방식(`append` -> `pop`)으로 짜는 게 정석**이야.
