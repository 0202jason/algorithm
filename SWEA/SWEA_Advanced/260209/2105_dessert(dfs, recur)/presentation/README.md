## 🏫 [강의] 디저트 카페 문제 완전 정복

### 1. 문제의 핵심 아이디어: "사각형의 성질"

사각형은 결국 **네 번의 직진**과 **세 번의 꺾기**로 이루어져 있어. (마지막 네 번째 꺾기는 시작점으로 돌아가는 거니까). 이걸 코드로 구현할 때 핵심은 **"지금 가던 길로 계속 갈래, 아니면 한 번 꺾을래?"**를 결정하는 거야.

### 2. 함수 파라미터 설계 (왜 이렇게 넘기는가?)

```python
def dfs(ci, cj, d, v):

```

* `ci, cj`: 현재 좌표 (Current I, Current J)
* `d`: 현재 내가 바라보고 있는 **방향 번호** (0, 1, 2, 3)
* `v`: 지금까지 먹은 디저트들을 담은 **장바구니** (List)

> **Best Practice:** 재귀 함수를 짤 때는 "현재 상태"를 나타내는 최소한의 변수를 인자로 넘겨야 해. 여기서 `d`를 넘기는 이유는 **방향을 거꾸로 되돌아가거나(U-turn) 뜬금없는 방향으로 꺾는 걸 방지**하기 위해서야.

---

### 3. 코드 한 줄 한 줄 씹어먹기

#### ① 방향 벡터의 순서

```python
di = [1, 1, -1, -1]
dj = [1, -1, -1, 1]

```

이건 그냥 대각선이 아니야. 순서대로 **우하 → 좌하 → 좌상 → 우상** 순이지? 이렇게 시계 방향(또는 반시계)으로 정렬해둬야 `d`에서 `d+1`로 자연스럽게 사각형을 그릴 수 있어.

#### ② 방향 전환 로직 (이게 핵심!)

```python
for k in range(d, d + 2):
    if k < 4:
        ni, nj = ci + di[k], cj + dj[k]

```

* `k = d`: 현재 방향 그대로 **직진**.
* `k = d + 1`: 다음 방향으로 **회전**.
* **왜 `d + 2`인가요?** 한 번의 이동에서 선택지는 두 개뿐이니까! (가던 길 가거나, 꺾거나)

#### ③ 백트래킹 (다시 돌아오기)

```python
v.append(matrix[ni][nj])
dfs(ni, nj, k, v)
v.pop()

```

이게 진짜 중요해. `v`는 리스트잖아? 파이썬에서 리스트는 주소값이 넘어가기 때문에(Mutable), 한쪽에서 추가하면 모든 재귀 함수가 같은 리스트를 공유해. 그래서 **탐색이 끝나면 내가 넣었던 걸 다시 빼줘야(pop)** 다른 경로를 탐색할 때 영향을 안 줘.

---

### 4. 이 코드의 치명적 단점 (장단점 분석)

| 항목 | 분석 |
| --- | --- |
| **장점** | 로직이 직관적임. 방향 전환을 `range(d, d+2)`로 제한해서 탐색 횟수를 엄청나게 줄임. |
| **단점 (성능)** | `matrix[ni][nj] not in v` 부분. 리스트에서 `in` 연산은 **O(N)**이야. 디저트 종류가 많아지면 여기서 시간이 끌려. |
| **개선안** | `visited = [0] * 101` (디저트 종류만큼의 체크 배열)을 만들어서 인덱스로 접근하면 **O(1)**로 해결 가능! |

---

### 5. 수업 마무리 확인 질문 (대답 못 하면 다시 공부!)

1. **Q:** 왜 `dfs` 함수 안에서 `for k in range(4):`를 돌리지 않고 `range(d, d+2)`를 돌렸을까? 만약 `range(4)`를 돌리면 어떤 문제가 생길까?
2. **Q:** 사각형이 되려면 최소한 몇 번 이동해야 할까? (코드에 `len(v)`가 최소 몇 이상이어야 유효한 사각형인지 조건이 없는데, 사실 없어도 돌아가는 이유가 뭘까?)
3. **Q:** 만약 `v`를 리스트가 아니라 `set()`으로 바꾼다면, 백트래킹(`pop`) 과정은 어떻게 수정해야 할까?

---
