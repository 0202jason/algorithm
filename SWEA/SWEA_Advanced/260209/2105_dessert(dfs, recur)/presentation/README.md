## 🏫 [강의] 디저트 카페 문제 완전 정복

### 1. 문제의 핵심 아이디어: "사각형의 성질"

사각형은 결국 **네 번의 직진**과 **세 번의 꺾기**로 이루어져 있어. (마지막 네 번째 꺾기는 시작점으로 돌아가는 거니까). 이걸 코드로 구현할 때 핵심은 **"지금 가던 길로 계속 갈래, 아니면 한 번 꺾을래?"**를 결정하는 거야.

### 2. 함수 파라미터 설계 (왜 이렇게 넘기는가?)

```python
def dfs(ci, cj, d, v):

```

* `ci, cj`: 현재 좌표 (Current I, Current J)
* `d`: 현재 내가 바라보고 있는 **방향 번호** (0, 1, 2, 3)
* `v`: 지금까지 먹은 디저트들을 담은 **장바구니** (List)

> **Best Practice:** 재귀 함수를 짤 때는 "현재 상태"를 나타내는 최소한의 변수를 인자로 넘겨야 해. 여기서 `d`를 넘기는 이유는 **방향을 거꾸로 되돌아가거나(U-turn) 뜬금없는 방향으로 꺾는 걸 방지**하기 위해서야.

---

### 3. 코드 한 줄 한 줄 씹어먹기

#### ① 방향 벡터의 순서

```python
di = [1, 1, -1, -1]
dj = [1, -1, -1, 1]

```

이건 그냥 대각선이 아니야. 순서대로 **우하 → 좌하 → 좌상 → 우상** 순이지? 이렇게 시계 방향(또는 반시계)으로 정렬해둬야 `d`에서 `d+1`로 자연스럽게 사각형을 그릴 수 있어.

#### ② 방향 전환 로직 (이게 핵심!)

```python
for k in range(d, d + 2):
    if k < 4:
        ni, nj = ci + di[k], cj + dj[k]

```

* `k = d`: 현재 방향 그대로 **직진**.
* `k = d + 1`: 다음 방향으로 **회전**.
* **왜 `d + 2`인가요?** 한 번의 이동에서 선택지는 두 개뿐이니까! (가던 길 가거나, 꺾거나)

#### ③ 백트래킹 (다시 돌아오기)

```python
v.append(matrix[ni][nj])
dfs(ni, nj, k, v)
v.pop()

```

이게 진짜 중요해. `v`는 리스트잖아? 파이썬에서 리스트는 주소값이 넘어가기 때문에(Mutable), 한쪽에서 추가하면 모든 재귀 함수가 같은 리스트를 공유해. 그래서 **탐색이 끝나면 내가 넣었던 걸 다시 빼줘야(pop)** 다른 경로를 탐색할 때 영향을 안 줘.

---

#### 스택에 쌓이는 과정 (Forward)

사각형의 첫 번째 변을 따라 이동한다고 가정해보자.

1. **Level 1:** `dfs(0, 0, 0, [9])` 호출 → 스택에 Push!
2. **Level 2:** `(1, 1)`로 이동. `dfs(1, 1, 0, [9, 8])` 호출 → 스택에 Push!
3. **Level 3:** 방향을 꺾어서 `(2, 0)`으로 이동. `dfs(2, 0, 1, [9, 8, 7])` 호출 → 스택에 Push!

#### 변수의 변화와 백트래킹 (Backward)

자, 여기서가 중요하다. 더 이상 갈 곳이 없거나 사각형을 완성해서 `return`을 만나면, 스택의 가장 위에 있는 프레임이 **Pop(제거)**되면서 이전 함수로 돌아가.

* **중요 포인트:** 네 코드의 `v.pop()`은 시스템 스택이 아니라, 네가 만든 **디저트 리스트 `v`**에서 마지막 값을 빼주는 거야. 그래야 이전 갈림길로 돌아왔을 때 내 장바구니(`v`)가 다시 예전 상태로 복구되거든.

---

## 📊 변수 추적 시뮬레이션 (Trace Table)

입력 행렬이 아래와 같다고 가정해보자.

```text
(0,0): 9  (0,1): 8
(1,0): 7  (1,1): 6

```

시작점 `(si, sj) = (0, 0)` 일 때:

| 호출 순서 | 함수 상태 (ci, cj, d) | 디저트 리스트 `v` (변화) | 동작 |
| --- | --- | --- | --- |
| **1** | `dfs(0, 0, 0)` | `[9]` | 시작! 우하향 이동 결정 |
| **2** | `dfs(1, 1, 0)` | `[9, 6]` | 이동 완료. 여기서 직진 or 꺾기 고민 |
| **3** | `dfs(2, 2, 0)` | `[9, 6, X]` | (범위 밖이라 가정) -> **Backtrack!** |
| **4** | `dfs(1, 1, 0)` 복귀 | `[9, 6]` | `v.pop()` 실행되어 `6` 제거 대기 |
| **5** | `dfs(2, 0, 1)` | `[9, 6, 7]` | 방향 `1`로 꺾어서 진행 |

---

## 🧠 백트래킹의 핵심: "내 일 끝났으니 원상복구해라"

결론부터 말하면, `v.pop()`은 **`dfs` 함수가 하나 종료(return)될 때마다 바로 직전 함수에서 실행**되는 거야.

### 1. 왜 `dfs()` 호출 바로 밑에 있을까?

재귀 호출은 함수가 끝날 때까지 다음 줄로 넘어가지 않아.

1. `v.append()`: "야, 나 이 카페 디저트 먹었어!" (장바구니에 넣기)
2. `dfs()`: "자, 그럼 다음 칸으로 가서 또 먹어봐." (다음 집 방문)
3. **... (한참 뒤에 다음 집 방문이 다 끝나고 돌아오면) ...**
4. `v.pop()`: "휴, 다음 집 투어 끝났네? 그럼 방금 먹었던 건 다시 빼줄게. 그래야 다른 길로 갈 때 배가 안 부르지!" (원상복구)

---


## 📊 시뮬레이션: 스택에서 벌어지는 일

간단하게 디저트 번호 `[9, 8, 7]` 순서로 이동한다고 생각해보자.

| 단계 | 현재 상태 | 행동 | 장바구니 `v` | 비고 |
| --- | --- | --- | --- | --- |
| **1** | `dfs(9)` 실행 | `v.append(8)` 후 `dfs(8)` 호출 | `[9, 8]` | 8번 방문 중 |
| **2** | `dfs(8)` 실행 | `v.append(7)` 후 `dfs(7)` 호출 | `[9, 8, 7]` | 7번 방문 중 |
| **3** | `dfs(7)` 끝 | 더 이상 갈 곳 없어 `return` | `[9, 8, 7]` | 함수 종료 |
| **4** | **`dfs(8)`로 복귀** | **`v.pop()` 실행!** | `[9, 8]` | **7번을 뱉어냄** |
| **5** | `dfs(8)` 끝 | `return` | `[9, 8]` | 함수 종료 |
| **6** | **`dfs(9)`로 복귀** | **`v.pop()` 실행!** | `[9]` | **8번을 뱉어냄** |

---

## 🧐 기술적 분석: 이 방식의 장점과 주의점

이걸 전문 용어로 **"State Restoration(상태 복구)"**라고 불러.

* **장점:** `v`라는 리스트 하나만 계속 돌려쓰니까 메모리를 엄청나게 아낄 수 있어. (새로 복사본을 안 만드니까)
* **주의점 (실수 포인트):** 만약 `v.pop()`을 안 하면? 한 번 경로 탐색할 때 먹은 디저트가 다음 경로 탐색할 때도 그대로 남아있어서, "어? 이거 아까 먹은 거네?" 하고 탐색을 안 해버리는 대참사가 발생해.

---


### 4. 이 코드의 치명적 단점 (장단점 분석)

| 항목 | 분석 |
| --- | --- |
| **장점** | 로직이 직관적임. 방향 전환을 `range(d, d+2)`로 제한해서 탐색 횟수를 엄청나게 줄임. |
| **단점 (성능)** | `matrix[ni][nj] not in v` 부분. 리스트에서 `in` 연산은 **O(N)**이야. 디저트 종류가 많아지면 여기서 시간이 끌려. |
| **개선안** | `visited = [0] * 101` (디저트 종류만큼의 체크 배열)을 만들어서 인덱스로 접근하면 **O(1)**로 해결 가능! |

---

### 5. 수업 마무리 확인 질문 (대답 못 하면 다시 공부!)

1. **Q:** 왜 `dfs` 함수 안에서 `for k in range(4):`를 돌리지 않고 `range(d, d+2)`를 돌렸을까? 만약 `range(4)`를 돌리면 어떤 문제가 생길까?
2. **Q:** 사각형이 되려면 최소한 몇 번 이동해야 할까? (코드에 `len(v)`가 최소 몇 이상이어야 유효한 사각형인지 조건이 없는데, 사실 없어도 돌아가는 이유가 뭘까?)
3. **Q:** 만약 `v`를 리스트가 아니라 `set()`으로 바꾼다면, 백트래킹(`pop`) 과정은 어떻게 수정해야 할까?

---
