# BFS 너비우선탐색
> 탐색 시작 정점에 인접한 정점들을 모두 차례로 방문한 후에,
> 방문했던 정점들을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

---

## 💡 BFS 핵심 로직 원리 및 힌트

코드를 작성하기 전, 머릿속에 이 **두 가지**를 먼저 박아 넣으세요.

1. **Queue(큐)의 활용**: 먼저 들어온 노드를 먼저 방문합니다 (FIFO). "가까운 곳부터 방문한다"는 원칙을 지키기 위함입니다.
2. **방문 처리(Visited)**: 이미 가본 곳을 또 가면 무한 루프에 빠집니다. 반드시 체크하세요.

> **[힌트]**
> BFS는 **최단 경로**를 찾을 때 강력합니다. 왜일까요? 1단계 거리인 노드를 다 보고, 그다음 2단계 거리를 보기 때문에 처음 목적지에 도달하는 순간이 곧 최소 이동 횟수가 되기 때문입니다.

---

# 📑 [README] Breadth-First Search (BFS)

## [개요]

**BFS**는 그래프 탐색 알고리즘으로, 시작 노드에서 가까운 노드부터 우선순위를 두어 인접한 모든 정점을 차례대로 방문하는 **수평적 탐색** 방식입니다.

## [로직 추적]

다음과 같은 그래프가 있다고 가정합니다.

* **연결 관계**: `A -> [B, C]`, `B -> [D, E]`, `C -> [F]`
* **시작점**: `A`

### Trace Table (변화 과정)

| Step | 현재 노드 | Queue 상태 (Next) | Visited (방문 완료) | 비고 |
| --- | --- | --- | --- | --- |
| 1 | - | `[A]` | `[]` | 시작 노드 삽입 |
| 2 | **A** | `[B, C]` | `[A]` | A 추출, 인접 B, C 삽입 |
| 3 | **B** | `[C, D, E]` | `[A, B]` | B 추출, 인접 D, E 삽입 |
| 4 | **C** | `[D, E, F]` | `[A, B, C]` | C 추출, 인접 F 삽입 |
| 5 | **D** | `[E, F]` | `[A, B, C, D]` | 자식 없음 |
| 6 | **E** | `[F]` | `[A, B, C, D, E]` | 자식 없음 |
| 7 | **F** | `[]` | `[A, B, C, D, E, F]` | 탐색 종료 |

## [코드]

파이썬의 `collections.deque`를 사용하는 것이 성능상 유리합니다 (`list.pop(0)`은 $O(N)$이지만, `deque.popleft()`는 $O(1)$입니다).

```python
from collections import deque

def bfs_example(graph, start_node):
    # 1. 방문 여부를 기록할 리스트 (또는 set)
    visited = set()
    
    # 2. 탐색을 위한 큐 생성 및 시작점 삽입
    queue = deque([start_node])
    visited.add(start_node)
    
    print(f"--- BFS 탐색 시작: {start_node} ---")
    
    while queue:
        # 큐에서 가장 앞에 있는 노드를 꺼냄 (FIFO)
        current = queue.popleft()
        print(f"현재 방문 중: {current}")
        
        # 현재 노드와 연결된 인접 노드 확인
        for neighbor in graph[current]:
            if neighbor not in visited:
                # 방문하지 않은 노드라면 큐에 넣고 방문 처리
                visited.add(neighbor)
                queue.append(neighbor)
                
    print("--- 탐색 완료 ---")

# 실행용 데이터 (인접 리스트 방식)
graph_data = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B'],
    'F': ['C']
}

bfs_example(graph_data, 'A')

```

### 🔍 디버깅 모드 가이드

* **Point 1**: `visited.add(neighbor)`의 위치를 확인하세요. 큐에 **넣을 때** 바로 방문 처리를 해야 중복 데이터가 큐에 쌓이는 것을 방지할 수 있습니다.
* **Point 2**: `queue.popleft()` 직후에 `current` 값을 출력해 보면 위 **Trace Table**의 순서와 일치하는지 확인할 수 있습니다.
* **Point 3**: 만약 연결이 끊긴 그래프(Disconnected Graph)라면 모든 노드를 방문하지 못할 수 있습니다. 이럴 땐 모든 노드에 대해 루프를 돌며 BFS를 실행해야 합니다.

## [분석]

* **장점**:
* **최단 경로 보장**: 가중치가 없는 그래프에서 시작점부터 목표점까지의 최단 거리를 확실히 찾아줍니다.
* 무한 루프에 빠질 위험이 DFS보다 적습니다 (방문 처리 시).


* **단점**:
* **메모리 소비**: 노드의 수가 많아질수록 큐에 저장되는 데이터가 급격히 늘어납니다.


* **실무 꿀팁**:
* 가중치가 있는 그래프의 최단 거리는 BFS가 아니라 **다익스트라(Dijkstra)** 를 써야 합니다. 헷갈리지 마세요.



## [활용]

1. **미로 찾기**: 최소 이동 칸수 구하기
2. **네트워크 탐색**: 소셜 네트워크에서 '나'와 '친구의 친구' 찾기
3. **그래프의 연결 성분 확인**: 총 몇 개의 그룹으로 나누어져 있는지 확인

---
