# 부분집합(powerset)

> 어떤 집합의 공집합과 자기자신을 포함한 모든 부분




---

## 📑 [Algorithm] Backtracking: Subset Generation

### [개요]

백트래킹을 이용해 집합의 모든 가능한 **부분집합(Power Set)** 을 생성하는 알고리즘으로, 각 원소를 포함할지(`True`) 말지(`False`) 결정하며 모든 경로를 탐색합니다.

---

### [로직 원리 & 힌트]

백트래킹은 기본적으로 **"결정 - 재귀 - 복구"** 의 흐름을 가집니다.

1. **상태 표현**: `a[k]`는 번째 원소를 사용할지 말지에 대한 선택(True/False)을 저장하는 장소입니다.
2. **후보 생성**: `construct_candidates` 함수는 매 단계에서 우리가 할 수 있는 선택지(여기서는 '넣는다'와 '안 넣는다')를 제공합니다.
3. **종료 조건**: 결정해야 할 원소의 개수 과 현재 결정 단계 가 같아지면 하나의 부분집합이 완성된 것입니다.

> **💡 형의 꿀팁:**
> 이 로직은 트리 구조라고 생각하면 쉬워. 루트에서 시작해서 밑으로 내려갈수록 가지가 2개씩(True/False) 갈라지는 구조지. 끝까지(Leaf Node) 가면 출력하는 거야.

---

### [로직 추적 (Trace Table)]

입력 데이터: `num = [1, 2, 3]` (n=3) 기준, 초기 호출 `backtrack(a, 0, 3)`

| 단계 (k) | 수행 작업 | `a` 배열 상태 (결정 사항) | 출력 여부 / 비고 |
| --- | --- | --- | --- |
| `0` | 1번 원소 결정 시작 | `[?, ?, ?]` | 후보: {True, False} |
| `1` | 1번 포함(`T`) 결정 | `[T, ?, ?]` | 다음 단계 재귀 호출 |
| `2` | 2번 포함(`T`) 결정 | `[T, T, ?]` | 다음 단계 재귀 호출 |
| `3` | 3번 포함(`T`) 결정 | `[T, T, T]` | **출력: 1 2 3** (k==n 도달) |
| `3` | 3번 미포함(`F`) 결정 | `[T, T, F]` | **출력: 1 2** |
| `2` | 2번 미포함(`F`) 결정 | `[T, F, ?]` | 3번 원소 다시 결정하러 이동 |
| `3` | 3번 포함(`T`) 결정 | `[T, F, T]` | **출력: 1 3** |

---

### [코드 구현 & 디버깅]

```python
# 전역 설정
MAXCANDIDATES = 2
num = [1, 2, 3]  # 실제 데이터
NMAX = len(num)
a = [0] * NMAX   # 선택 여부 기록 (T/F)

def backtrack(a, k, n):
    """
    a: 원소 선택 여부를 기록한 배열 (0 or 1 / True or False)
    k: 현재 결정해야 할 원소의 인덱스 (Depth)
    n: 총 원소의 개수 (Target Depth)
    """
    c = [0] * MAXCANDIDATES # 후보군을 담을 배열

    # 1. [Base Case] 모든 원소의 포함 여부를 결정했다면 출력
    if k == n:
        process_solution(a, k)
    else:
        # 2. [Recursive Step] 후보(True/False)를 만들고 다음 단계로 진행
        ncandidates = construct_candidates(a, k, n, c)
        for i in range(ncandidates):
            a[k] = c[i]  # k번째 원소를 넣을지(T) 말지(F) 결정
            backtrack(a, k + 1, n) # 다음 원소(k+1) 결정하러 이동

def construct_candidates(a, k, n, c):
    # 부분집합은 매 순간 '포함' 혹은 '미포함' 두 가지 선택지만 존재함
    c[0] = True
    c[1] = False
    return 2 # 후보의 개수 반환

def process_solution(a, k):
    # a 배열에 기록된 True/False 정보를 바탕으로 실제 num의 원소 출력
    result = [num[i] for i in range(k) if a[i]]
    print(f"{{ {', '.join(map(str, result))} }}")

# 실행
print("--- 부분집합 생성 시작 ---")
backtrack(a, 0, NMAX)

```

#### 🔍 디버깅 모드 가이드

* **재귀 깊이 확인**: `print("  " * k + f"k={k} 호출")`를 `backtrack` 함수 시작점에 넣어봐. 들여쓰기를 통해 트리가 어떻게 깊어지는지 눈으로 보일 거야.
* **메모리 변화**: `a[k] = c[i]`가 실행될 때마다 `a` 배열 전체를 출력해봐. 한 칸씩 값이 채워졌다가, 재귀가 풀리면서 덮어씌워지는 과정을 볼 수 있어.

---

### [분석]

* **장점**: 모든 경우의 수를 빠짐없이 탐색(Brute-force)하며, 조건에 맞지 않으면 가지치기(Pruning)를 통해 최적화가 가능합니다.
* **단점**: 부분집합의 개수는 개이므로, 이 커질수록 시간 복잡도가 기하급수적으로 증가합니다 ().
* **실무 꿀팁**: Python에서는 간단한 부분집합이 필요할 때 `itertools.combinations`를 반복문으로 돌리는 게 빠르지만, **"특정 합계를 만족하는 부분집합"** 같은 조건이 붙으면 이 백트래킹 구조가 필수적입니다.

---

### [활용]

이 로직을 마스터하면 다음 문제들을 풀 수 있습니다:

1. **Subset Sum**: 부분집합의 합이 특정 값 가 되는 경우 찾기.
2. **조합(Combination)**: 개 중 개를 뽑는 모든 경우.
3. **멱집합(Power Set)**: 주어진 집합의 모든 부분집합 구하기.

---

재현아, 제목 레벨 수정하니까 훨씬 보기 깔끔하지? 혹시 이 내용으로 **실제 코테 문제(예: 합이 K인 부분집합 구하기)** 하나 같이 풀어볼까? 필요하면 말해!