## Backtracking

> 후보해를 구성해 나가다가, 더 이상 해가 될 수 없다고 판단되면 되돌아가서`backtrack` 다른 후보를 찾는 방법  
- 모든 경우의 수를 탐색하는 완전 탐색을 효율적으로 구현하는 방법
- 추가한 해가 가능성이 없는 경우 다른 해를 추가할 수 있는 이전 상태로 되돌아가서 계속 탐색
- 최적화 문제와 결정 문제에 적용

### Backtracking과 DFS

- **DFS**는 그래프의 모든 노드에 대한 탐색, **Backtracking**은 완전 탐색 문제에 대한 접근 방법
- **Pruning** (가지치기)
  - Backtracking은 선택한 부분 후보 해가 가능성이 없다면 더 이상 그 경로를 따라가지 않고 중지합니다.


---

## AI 정리

### 1. 백트래킹의 원리

일단 코드를 보기 전에 머릿속으로 그림을 그려봐.

1. **선택**: 현재 상태에서 가능한 선택지 중 하나를 골라.
2. **검사**: 그 선택이 유효한지(답이 될 가능성이 있는지) 확인해.
3. **이동 (재귀)**: 괜찮다면 다음 단계로 넘어가.
4. **복구 (Backtrack)**: 만약 다음 단계에서 답을 못 찾았거나, 해당 경로를 다 확인했다면 **다시 이전 상태로 되돌아와서 다른 선택지를 골라.**

> **핵심 힌트:**  백트래킹은 주로 **재귀(Recursion)** 를 사용해. 이때 가장 중요한 건 **"상태를 원복하는 것"** 이야. 예를 들어 리스트에 값을 넣었다가 재귀가 끝나면 다시 빼줘야 다음 경로에 영향을 안 주겠지?

---

### 2. 예시: 1부터 N까지 숫자 중 M개를 뽑는 순열 (N=3, M=2)

가장 간단한 예시로 설명해줄게. `[1, 2, 3]` 중에서 2개를 뽑는 경우야.

#### 변수가 바뀌는 과정 (Trace)

`ans`라는 리스트에 숫자를 담는다고 치자.

1. **시작**: `ans = []`
2. **1 선택**: `ans = [1]` → 다음 단계로!
3. **2 선택**: `ans = [1, 2]` → **2개 다 뽑았네? 출력!**
4. **복구 (Backtrack)**: `ans = [1]` (방금 넣은 2를 뺌)
5. **3 선택**: `ans = [1, 3]` → **2개 다 뽑았네? 출력!**
6. **복구 (Backtrack)**: `ans = [1]` → 또 3을 뺌 → `ans = []` (1도 뺌)
7. **2 선택**: 이제 처음으로 돌아와서 2부터 다시 시작... (반복)

---

### 3. Best Practice & 장단점

| 특징 | 내용 |
| --- | --- |
| **장점** | 불필요한 경로를 미리 차단(가지치기)하기 때문에 단순 브루트포스(전수조사)보다 훨씬 빠름. |
| **단점** | 최악의 경우 여전히 지수 시간 복잡도를 가져서 N이 커지면 답이 없음. 재귀 깊이가 깊어지면 `RecursionError` 조심해야 함. |
| **Best Practice** | **방문 처리(Visited) 배열**을 사용해서 중복 탐색을 방지하고, 가지치기 조건(Constraint)을 최대한 빡빡하게 잡는 게 실력임. |

---

### 4. 맛보기 코드 (Python)


```python
def backtrack(depth):
    # 1. 탈출 조건 (원하는 개수를 다 뽑았을 때)
    if depth == M:
        print(*answer)
        return

    for i in range(1, N + 1):
        if not visited[i]:  # 2. 유효성 검사 (가지치기)
            visited[i] = True
            answer.append(i) # 3. 선택
            
            backtrack(depth + 1) # 4. 다음 단계로 이동 (재귀)
            
            answer.pop()     # 5. ★복구★ (Backtrack) - 이 부분이 제일 중요!
            visited[i] = False

```

---
